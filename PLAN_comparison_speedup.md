# 比較処理高速化プラン

## 現状分析

100ページのドキュメント比較で15-30秒かかっている。

## ボトルネック

### 1. 重複比較 (最重要 - 2倍高速化)
**場所**: `src/gui_pyside/main_window.py:1560-1566`

**問題**:
- `compare(left, right)` と `compare(right, left)` を両方実行
- 差分検出は同じ結果なのに2回計算している

**解決策**:
- 1回の比較で差分マスクを取得
- 左右のハイライト画像を同じマスクから生成

**期待効果**: 2倍高速化

---

### 2. 逐次処理ループ (重要 - 3-6倍高速化)
**場所**: `src/gui_pyside/main_window.py:1538-1572`

**問題**:
- 各ページペアを順番に処理
- GUIスレッドをブロック

**解決策**:
- `ThreadPoolExecutor` で並列化 (4-8ワーカー)
- 進捗表示は `queue` 経由で更新

**期待効果**: 3-6倍高速化 (CPUコア数依存)

---

### 3. ハイライト画像生成 (中程度 - 1.3倍高速化)
**場所**: `src/core/image_comparator.py:213-238`

**問題**:
- 配列の完全コピー
- ループ内でのブレンド処理

**解決策**:
- NumPyのベクトル化操作でマスク適用
- インプレース操作で不要なコピーを削減

**期待効果**: 1.3倍高速化

---

## 実装順序

### Phase 1: 重複比較の削除 (低リスク・高効果)
1. `image_comparator.py` に `compare_once()` メソッド追加
   - 差分マスクと両側のハイライト画像を1回で返す
2. GUI側の呼び出しを修正
3. テスト

**推定工数**: 小
**リスク**: 低

### Phase 2: 並列処理化 (中リスク・高効果)
1. 比較ワーカー関数を作成
2. `ThreadPoolExecutor` でページペアを並列処理
3. 進捗バーの更新をスレッドセーフに
4. エラーハンドリング

**推定工数**: 中
**リスク**: 中 (スレッド同期の問題に注意)

### Phase 3: ハイライト生成最適化 (低リスク・中効果)
1. NumPyベクトル化操作に置き換え
2. 不要なコピーを削除

**推定工数**: 小
**リスク**: 低

---

## 期待される総合効果

| Phase | 高速化倍率 | 累積効果 |
|-------|-----------|---------|
| Phase 1 | 2× | 2× |
| Phase 2 | 3-6× | 6-12× |
| Phase 3 | 1.3× | 8-15× |

**100ページ比較**: 15-30秒 → 2-4秒

---

## 既に最適化済み (変更不要)

- pHash計算: `ThreadPoolExecutor` で並列化済み
- ディスクキャッシュ: サムネイルを `~/.pptpdf_cache` に保存
- PowerPoint COM: インスタンス再利用済み

---

## 変更対象ファイル

- `src/core/image_comparator.py` - 比較ロジック改善
- `src/gui_pyside/main_window.py` - 並列処理・呼び出し修正
- `src/gui_wx/main_window.py` - 同上
